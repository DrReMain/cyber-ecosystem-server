// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.5.1
// - protoc             v6.32.0
// source: rpc/admin_system/admin_system.proto

package admin_system

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	BaseService_InitDB_FullMethodName = "/admin_system.BaseService/InitDB"
)

// BaseServiceClient is the client API for BaseService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type BaseServiceClient interface {
	InitDB(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*BaseRes, error)
}

type baseServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewBaseServiceClient(cc grpc.ClientConnInterface) BaseServiceClient {
	return &baseServiceClient{cc}
}

func (c *baseServiceClient) InitDB(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*BaseRes, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(BaseRes)
	err := c.cc.Invoke(ctx, BaseService_InitDB_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// BaseServiceServer is the server API for BaseService service.
// All implementations must embed UnimplementedBaseServiceServer
// for forward compatibility.
type BaseServiceServer interface {
	InitDB(context.Context, *Empty) (*BaseRes, error)
	mustEmbedUnimplementedBaseServiceServer()
}

// UnimplementedBaseServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedBaseServiceServer struct{}

func (UnimplementedBaseServiceServer) InitDB(context.Context, *Empty) (*BaseRes, error) {
	return nil, status.Errorf(codes.Unimplemented, "method InitDB not implemented")
}
func (UnimplementedBaseServiceServer) mustEmbedUnimplementedBaseServiceServer() {}
func (UnimplementedBaseServiceServer) testEmbeddedByValue()                     {}

// UnsafeBaseServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to BaseServiceServer will
// result in compilation errors.
type UnsafeBaseServiceServer interface {
	mustEmbedUnimplementedBaseServiceServer()
}

func RegisterBaseServiceServer(s grpc.ServiceRegistrar, srv BaseServiceServer) {
	// If the following call pancis, it indicates UnimplementedBaseServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&BaseService_ServiceDesc, srv)
}

func _BaseService_InitDB_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BaseServiceServer).InitDB(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BaseService_InitDB_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BaseServiceServer).InitDB(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

// BaseService_ServiceDesc is the grpc.ServiceDesc for BaseService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var BaseService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "admin_system.BaseService",
	HandlerType: (*BaseServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "InitDB",
			Handler:    _BaseService_InitDB_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "rpc/admin_system/admin_system.proto",
}

const (
	CasbinService_QueryCasbinByRole_FullMethodName = "/admin_system.CasbinService/queryCasbinByRole"
	CasbinService_QueryRoleByMenu_FullMethodName   = "/admin_system.CasbinService/queryRoleByMenu"
	CasbinService_QueryRoleByRole_FullMethodName   = "/admin_system.CasbinService/queryRoleByRole"
)

// CasbinServiceClient is the client API for CasbinService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type CasbinServiceClient interface {
	QueryCasbinByRole(ctx context.Context, in *CasbinReq, opts ...grpc.CallOption) (*CasbinRes, error)
	QueryRoleByMenu(ctx context.Context, in *RoleFromMenuReq, opts ...grpc.CallOption) (*RoleFromMenuRes, error)
	QueryRoleByRole(ctx context.Context, in *RoleFromRoleReq, opts ...grpc.CallOption) (*RoleFromRoleRes, error)
}

type casbinServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewCasbinServiceClient(cc grpc.ClientConnInterface) CasbinServiceClient {
	return &casbinServiceClient{cc}
}

func (c *casbinServiceClient) QueryCasbinByRole(ctx context.Context, in *CasbinReq, opts ...grpc.CallOption) (*CasbinRes, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CasbinRes)
	err := c.cc.Invoke(ctx, CasbinService_QueryCasbinByRole_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *casbinServiceClient) QueryRoleByMenu(ctx context.Context, in *RoleFromMenuReq, opts ...grpc.CallOption) (*RoleFromMenuRes, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(RoleFromMenuRes)
	err := c.cc.Invoke(ctx, CasbinService_QueryRoleByMenu_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *casbinServiceClient) QueryRoleByRole(ctx context.Context, in *RoleFromRoleReq, opts ...grpc.CallOption) (*RoleFromRoleRes, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(RoleFromRoleRes)
	err := c.cc.Invoke(ctx, CasbinService_QueryRoleByRole_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// CasbinServiceServer is the server API for CasbinService service.
// All implementations must embed UnimplementedCasbinServiceServer
// for forward compatibility.
type CasbinServiceServer interface {
	QueryCasbinByRole(context.Context, *CasbinReq) (*CasbinRes, error)
	QueryRoleByMenu(context.Context, *RoleFromMenuReq) (*RoleFromMenuRes, error)
	QueryRoleByRole(context.Context, *RoleFromRoleReq) (*RoleFromRoleRes, error)
	mustEmbedUnimplementedCasbinServiceServer()
}

// UnimplementedCasbinServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedCasbinServiceServer struct{}

func (UnimplementedCasbinServiceServer) QueryCasbinByRole(context.Context, *CasbinReq) (*CasbinRes, error) {
	return nil, status.Errorf(codes.Unimplemented, "method QueryCasbinByRole not implemented")
}
func (UnimplementedCasbinServiceServer) QueryRoleByMenu(context.Context, *RoleFromMenuReq) (*RoleFromMenuRes, error) {
	return nil, status.Errorf(codes.Unimplemented, "method QueryRoleByMenu not implemented")
}
func (UnimplementedCasbinServiceServer) QueryRoleByRole(context.Context, *RoleFromRoleReq) (*RoleFromRoleRes, error) {
	return nil, status.Errorf(codes.Unimplemented, "method QueryRoleByRole not implemented")
}
func (UnimplementedCasbinServiceServer) mustEmbedUnimplementedCasbinServiceServer() {}
func (UnimplementedCasbinServiceServer) testEmbeddedByValue()                       {}

// UnsafeCasbinServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to CasbinServiceServer will
// result in compilation errors.
type UnsafeCasbinServiceServer interface {
	mustEmbedUnimplementedCasbinServiceServer()
}

func RegisterCasbinServiceServer(s grpc.ServiceRegistrar, srv CasbinServiceServer) {
	// If the following call pancis, it indicates UnimplementedCasbinServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&CasbinService_ServiceDesc, srv)
}

func _CasbinService_QueryCasbinByRole_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CasbinReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CasbinServiceServer).QueryCasbinByRole(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CasbinService_QueryCasbinByRole_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CasbinServiceServer).QueryCasbinByRole(ctx, req.(*CasbinReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _CasbinService_QueryRoleByMenu_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RoleFromMenuReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CasbinServiceServer).QueryRoleByMenu(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CasbinService_QueryRoleByMenu_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CasbinServiceServer).QueryRoleByMenu(ctx, req.(*RoleFromMenuReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _CasbinService_QueryRoleByRole_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RoleFromRoleReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CasbinServiceServer).QueryRoleByRole(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CasbinService_QueryRoleByRole_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CasbinServiceServer).QueryRoleByRole(ctx, req.(*RoleFromRoleReq))
	}
	return interceptor(ctx, in, info, handler)
}

// CasbinService_ServiceDesc is the grpc.ServiceDesc for CasbinService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var CasbinService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "admin_system.CasbinService",
	HandlerType: (*CasbinServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "queryCasbinByRole",
			Handler:    _CasbinService_QueryCasbinByRole_Handler,
		},
		{
			MethodName: "queryRoleByMenu",
			Handler:    _CasbinService_QueryRoleByMenu_Handler,
		},
		{
			MethodName: "queryRoleByRole",
			Handler:    _CasbinService_QueryRoleByRole_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "rpc/admin_system/admin_system.proto",
}

const (
	DepartmentService_CreateDepartment_FullMethodName = "/admin_system.DepartmentService/createDepartment"
	DepartmentService_DeleteDepartment_FullMethodName = "/admin_system.DepartmentService/deleteDepartment"
	DepartmentService_UpdateDepartment_FullMethodName = "/admin_system.DepartmentService/updateDepartment"
	DepartmentService_GetDepartment_FullMethodName    = "/admin_system.DepartmentService/getDepartment"
	DepartmentService_QueryDepartment_FullMethodName  = "/admin_system.DepartmentService/queryDepartment"
)

// DepartmentServiceClient is the client API for DepartmentService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type DepartmentServiceClient interface {
	CreateDepartment(ctx context.Context, in *DepartmentBody, opts ...grpc.CallOption) (*BaseIDRes, error)
	DeleteDepartment(ctx context.Context, in *IDsReq, opts ...grpc.CallOption) (*BaseRes, error)
	UpdateDepartment(ctx context.Context, in *DepartmentBody, opts ...grpc.CallOption) (*BaseRes, error)
	GetDepartment(ctx context.Context, in *IDReq, opts ...grpc.CallOption) (*DepartmentBody, error)
	QueryDepartment(ctx context.Context, in *DepartmentListReq, opts ...grpc.CallOption) (*DepartmentListRes, error)
}

type departmentServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewDepartmentServiceClient(cc grpc.ClientConnInterface) DepartmentServiceClient {
	return &departmentServiceClient{cc}
}

func (c *departmentServiceClient) CreateDepartment(ctx context.Context, in *DepartmentBody, opts ...grpc.CallOption) (*BaseIDRes, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(BaseIDRes)
	err := c.cc.Invoke(ctx, DepartmentService_CreateDepartment_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *departmentServiceClient) DeleteDepartment(ctx context.Context, in *IDsReq, opts ...grpc.CallOption) (*BaseRes, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(BaseRes)
	err := c.cc.Invoke(ctx, DepartmentService_DeleteDepartment_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *departmentServiceClient) UpdateDepartment(ctx context.Context, in *DepartmentBody, opts ...grpc.CallOption) (*BaseRes, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(BaseRes)
	err := c.cc.Invoke(ctx, DepartmentService_UpdateDepartment_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *departmentServiceClient) GetDepartment(ctx context.Context, in *IDReq, opts ...grpc.CallOption) (*DepartmentBody, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DepartmentBody)
	err := c.cc.Invoke(ctx, DepartmentService_GetDepartment_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *departmentServiceClient) QueryDepartment(ctx context.Context, in *DepartmentListReq, opts ...grpc.CallOption) (*DepartmentListRes, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DepartmentListRes)
	err := c.cc.Invoke(ctx, DepartmentService_QueryDepartment_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// DepartmentServiceServer is the server API for DepartmentService service.
// All implementations must embed UnimplementedDepartmentServiceServer
// for forward compatibility.
type DepartmentServiceServer interface {
	CreateDepartment(context.Context, *DepartmentBody) (*BaseIDRes, error)
	DeleteDepartment(context.Context, *IDsReq) (*BaseRes, error)
	UpdateDepartment(context.Context, *DepartmentBody) (*BaseRes, error)
	GetDepartment(context.Context, *IDReq) (*DepartmentBody, error)
	QueryDepartment(context.Context, *DepartmentListReq) (*DepartmentListRes, error)
	mustEmbedUnimplementedDepartmentServiceServer()
}

// UnimplementedDepartmentServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedDepartmentServiceServer struct{}

func (UnimplementedDepartmentServiceServer) CreateDepartment(context.Context, *DepartmentBody) (*BaseIDRes, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateDepartment not implemented")
}
func (UnimplementedDepartmentServiceServer) DeleteDepartment(context.Context, *IDsReq) (*BaseRes, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteDepartment not implemented")
}
func (UnimplementedDepartmentServiceServer) UpdateDepartment(context.Context, *DepartmentBody) (*BaseRes, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateDepartment not implemented")
}
func (UnimplementedDepartmentServiceServer) GetDepartment(context.Context, *IDReq) (*DepartmentBody, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetDepartment not implemented")
}
func (UnimplementedDepartmentServiceServer) QueryDepartment(context.Context, *DepartmentListReq) (*DepartmentListRes, error) {
	return nil, status.Errorf(codes.Unimplemented, "method QueryDepartment not implemented")
}
func (UnimplementedDepartmentServiceServer) mustEmbedUnimplementedDepartmentServiceServer() {}
func (UnimplementedDepartmentServiceServer) testEmbeddedByValue()                           {}

// UnsafeDepartmentServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to DepartmentServiceServer will
// result in compilation errors.
type UnsafeDepartmentServiceServer interface {
	mustEmbedUnimplementedDepartmentServiceServer()
}

func RegisterDepartmentServiceServer(s grpc.ServiceRegistrar, srv DepartmentServiceServer) {
	// If the following call pancis, it indicates UnimplementedDepartmentServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&DepartmentService_ServiceDesc, srv)
}

func _DepartmentService_CreateDepartment_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DepartmentBody)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DepartmentServiceServer).CreateDepartment(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DepartmentService_CreateDepartment_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DepartmentServiceServer).CreateDepartment(ctx, req.(*DepartmentBody))
	}
	return interceptor(ctx, in, info, handler)
}

func _DepartmentService_DeleteDepartment_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IDsReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DepartmentServiceServer).DeleteDepartment(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DepartmentService_DeleteDepartment_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DepartmentServiceServer).DeleteDepartment(ctx, req.(*IDsReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _DepartmentService_UpdateDepartment_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DepartmentBody)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DepartmentServiceServer).UpdateDepartment(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DepartmentService_UpdateDepartment_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DepartmentServiceServer).UpdateDepartment(ctx, req.(*DepartmentBody))
	}
	return interceptor(ctx, in, info, handler)
}

func _DepartmentService_GetDepartment_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IDReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DepartmentServiceServer).GetDepartment(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DepartmentService_GetDepartment_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DepartmentServiceServer).GetDepartment(ctx, req.(*IDReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _DepartmentService_QueryDepartment_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DepartmentListReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DepartmentServiceServer).QueryDepartment(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DepartmentService_QueryDepartment_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DepartmentServiceServer).QueryDepartment(ctx, req.(*DepartmentListReq))
	}
	return interceptor(ctx, in, info, handler)
}

// DepartmentService_ServiceDesc is the grpc.ServiceDesc for DepartmentService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var DepartmentService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "admin_system.DepartmentService",
	HandlerType: (*DepartmentServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "createDepartment",
			Handler:    _DepartmentService_CreateDepartment_Handler,
		},
		{
			MethodName: "deleteDepartment",
			Handler:    _DepartmentService_DeleteDepartment_Handler,
		},
		{
			MethodName: "updateDepartment",
			Handler:    _DepartmentService_UpdateDepartment_Handler,
		},
		{
			MethodName: "getDepartment",
			Handler:    _DepartmentService_GetDepartment_Handler,
		},
		{
			MethodName: "queryDepartment",
			Handler:    _DepartmentService_QueryDepartment_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "rpc/admin_system/admin_system.proto",
}

const (
	MenuService_CreateMenu_FullMethodName          = "/admin_system.MenuService/createMenu"
	MenuService_DeleteMenu_FullMethodName          = "/admin_system.MenuService/deleteMenu"
	MenuService_UpdateMenu_FullMethodName          = "/admin_system.MenuService/updateMenu"
	MenuService_GetMenu_FullMethodName             = "/admin_system.MenuService/getMenu"
	MenuService_QueryMenu_FullMethodName           = "/admin_system.MenuService/queryMenu"
	MenuService_QueryMenuByRoleCode_FullMethodName = "/admin_system.MenuService/queryMenuByRoleCode"
)

// MenuServiceClient is the client API for MenuService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type MenuServiceClient interface {
	CreateMenu(ctx context.Context, in *MenuBody, opts ...grpc.CallOption) (*BaseIDRes, error)
	DeleteMenu(ctx context.Context, in *IDsReq, opts ...grpc.CallOption) (*BaseRes, error)
	UpdateMenu(ctx context.Context, in *MenuBody, opts ...grpc.CallOption) (*BaseRes, error)
	GetMenu(ctx context.Context, in *IDReq, opts ...grpc.CallOption) (*MenuBody, error)
	QueryMenu(ctx context.Context, in *MenuListReq, opts ...grpc.CallOption) (*MenuListRes, error)
	QueryMenuByRoleCode(ctx context.Context, in *MenuListByRoleCodeReq, opts ...grpc.CallOption) (*MenuListRes, error)
}

type menuServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewMenuServiceClient(cc grpc.ClientConnInterface) MenuServiceClient {
	return &menuServiceClient{cc}
}

func (c *menuServiceClient) CreateMenu(ctx context.Context, in *MenuBody, opts ...grpc.CallOption) (*BaseIDRes, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(BaseIDRes)
	err := c.cc.Invoke(ctx, MenuService_CreateMenu_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *menuServiceClient) DeleteMenu(ctx context.Context, in *IDsReq, opts ...grpc.CallOption) (*BaseRes, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(BaseRes)
	err := c.cc.Invoke(ctx, MenuService_DeleteMenu_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *menuServiceClient) UpdateMenu(ctx context.Context, in *MenuBody, opts ...grpc.CallOption) (*BaseRes, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(BaseRes)
	err := c.cc.Invoke(ctx, MenuService_UpdateMenu_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *menuServiceClient) GetMenu(ctx context.Context, in *IDReq, opts ...grpc.CallOption) (*MenuBody, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(MenuBody)
	err := c.cc.Invoke(ctx, MenuService_GetMenu_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *menuServiceClient) QueryMenu(ctx context.Context, in *MenuListReq, opts ...grpc.CallOption) (*MenuListRes, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(MenuListRes)
	err := c.cc.Invoke(ctx, MenuService_QueryMenu_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *menuServiceClient) QueryMenuByRoleCode(ctx context.Context, in *MenuListByRoleCodeReq, opts ...grpc.CallOption) (*MenuListRes, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(MenuListRes)
	err := c.cc.Invoke(ctx, MenuService_QueryMenuByRoleCode_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// MenuServiceServer is the server API for MenuService service.
// All implementations must embed UnimplementedMenuServiceServer
// for forward compatibility.
type MenuServiceServer interface {
	CreateMenu(context.Context, *MenuBody) (*BaseIDRes, error)
	DeleteMenu(context.Context, *IDsReq) (*BaseRes, error)
	UpdateMenu(context.Context, *MenuBody) (*BaseRes, error)
	GetMenu(context.Context, *IDReq) (*MenuBody, error)
	QueryMenu(context.Context, *MenuListReq) (*MenuListRes, error)
	QueryMenuByRoleCode(context.Context, *MenuListByRoleCodeReq) (*MenuListRes, error)
	mustEmbedUnimplementedMenuServiceServer()
}

// UnimplementedMenuServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedMenuServiceServer struct{}

func (UnimplementedMenuServiceServer) CreateMenu(context.Context, *MenuBody) (*BaseIDRes, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateMenu not implemented")
}
func (UnimplementedMenuServiceServer) DeleteMenu(context.Context, *IDsReq) (*BaseRes, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteMenu not implemented")
}
func (UnimplementedMenuServiceServer) UpdateMenu(context.Context, *MenuBody) (*BaseRes, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateMenu not implemented")
}
func (UnimplementedMenuServiceServer) GetMenu(context.Context, *IDReq) (*MenuBody, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetMenu not implemented")
}
func (UnimplementedMenuServiceServer) QueryMenu(context.Context, *MenuListReq) (*MenuListRes, error) {
	return nil, status.Errorf(codes.Unimplemented, "method QueryMenu not implemented")
}
func (UnimplementedMenuServiceServer) QueryMenuByRoleCode(context.Context, *MenuListByRoleCodeReq) (*MenuListRes, error) {
	return nil, status.Errorf(codes.Unimplemented, "method QueryMenuByRoleCode not implemented")
}
func (UnimplementedMenuServiceServer) mustEmbedUnimplementedMenuServiceServer() {}
func (UnimplementedMenuServiceServer) testEmbeddedByValue()                     {}

// UnsafeMenuServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to MenuServiceServer will
// result in compilation errors.
type UnsafeMenuServiceServer interface {
	mustEmbedUnimplementedMenuServiceServer()
}

func RegisterMenuServiceServer(s grpc.ServiceRegistrar, srv MenuServiceServer) {
	// If the following call pancis, it indicates UnimplementedMenuServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&MenuService_ServiceDesc, srv)
}

func _MenuService_CreateMenu_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MenuBody)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MenuServiceServer).CreateMenu(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MenuService_CreateMenu_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MenuServiceServer).CreateMenu(ctx, req.(*MenuBody))
	}
	return interceptor(ctx, in, info, handler)
}

func _MenuService_DeleteMenu_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IDsReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MenuServiceServer).DeleteMenu(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MenuService_DeleteMenu_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MenuServiceServer).DeleteMenu(ctx, req.(*IDsReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _MenuService_UpdateMenu_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MenuBody)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MenuServiceServer).UpdateMenu(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MenuService_UpdateMenu_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MenuServiceServer).UpdateMenu(ctx, req.(*MenuBody))
	}
	return interceptor(ctx, in, info, handler)
}

func _MenuService_GetMenu_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IDReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MenuServiceServer).GetMenu(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MenuService_GetMenu_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MenuServiceServer).GetMenu(ctx, req.(*IDReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _MenuService_QueryMenu_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MenuListReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MenuServiceServer).QueryMenu(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MenuService_QueryMenu_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MenuServiceServer).QueryMenu(ctx, req.(*MenuListReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _MenuService_QueryMenuByRoleCode_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MenuListByRoleCodeReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MenuServiceServer).QueryMenuByRoleCode(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MenuService_QueryMenuByRoleCode_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MenuServiceServer).QueryMenuByRoleCode(ctx, req.(*MenuListByRoleCodeReq))
	}
	return interceptor(ctx, in, info, handler)
}

// MenuService_ServiceDesc is the grpc.ServiceDesc for MenuService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var MenuService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "admin_system.MenuService",
	HandlerType: (*MenuServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "createMenu",
			Handler:    _MenuService_CreateMenu_Handler,
		},
		{
			MethodName: "deleteMenu",
			Handler:    _MenuService_DeleteMenu_Handler,
		},
		{
			MethodName: "updateMenu",
			Handler:    _MenuService_UpdateMenu_Handler,
		},
		{
			MethodName: "getMenu",
			Handler:    _MenuService_GetMenu_Handler,
		},
		{
			MethodName: "queryMenu",
			Handler:    _MenuService_QueryMenu_Handler,
		},
		{
			MethodName: "queryMenuByRoleCode",
			Handler:    _MenuService_QueryMenuByRoleCode_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "rpc/admin_system/admin_system.proto",
}

const (
	PositionService_CreatePosition_FullMethodName = "/admin_system.PositionService/createPosition"
	PositionService_DeletePosition_FullMethodName = "/admin_system.PositionService/deletePosition"
	PositionService_UpdatePosition_FullMethodName = "/admin_system.PositionService/updatePosition"
	PositionService_GetPosition_FullMethodName    = "/admin_system.PositionService/getPosition"
	PositionService_QueryPosition_FullMethodName  = "/admin_system.PositionService/queryPosition"
)

// PositionServiceClient is the client API for PositionService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type PositionServiceClient interface {
	CreatePosition(ctx context.Context, in *PositionBody, opts ...grpc.CallOption) (*BaseIDRes, error)
	DeletePosition(ctx context.Context, in *IDsReq, opts ...grpc.CallOption) (*BaseRes, error)
	UpdatePosition(ctx context.Context, in *PositionBody, opts ...grpc.CallOption) (*BaseRes, error)
	GetPosition(ctx context.Context, in *IDReq, opts ...grpc.CallOption) (*PositionBody, error)
	QueryPosition(ctx context.Context, in *PositionListReq, opts ...grpc.CallOption) (*PositionListRes, error)
}

type positionServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewPositionServiceClient(cc grpc.ClientConnInterface) PositionServiceClient {
	return &positionServiceClient{cc}
}

func (c *positionServiceClient) CreatePosition(ctx context.Context, in *PositionBody, opts ...grpc.CallOption) (*BaseIDRes, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(BaseIDRes)
	err := c.cc.Invoke(ctx, PositionService_CreatePosition_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *positionServiceClient) DeletePosition(ctx context.Context, in *IDsReq, opts ...grpc.CallOption) (*BaseRes, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(BaseRes)
	err := c.cc.Invoke(ctx, PositionService_DeletePosition_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *positionServiceClient) UpdatePosition(ctx context.Context, in *PositionBody, opts ...grpc.CallOption) (*BaseRes, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(BaseRes)
	err := c.cc.Invoke(ctx, PositionService_UpdatePosition_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *positionServiceClient) GetPosition(ctx context.Context, in *IDReq, opts ...grpc.CallOption) (*PositionBody, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(PositionBody)
	err := c.cc.Invoke(ctx, PositionService_GetPosition_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *positionServiceClient) QueryPosition(ctx context.Context, in *PositionListReq, opts ...grpc.CallOption) (*PositionListRes, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(PositionListRes)
	err := c.cc.Invoke(ctx, PositionService_QueryPosition_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// PositionServiceServer is the server API for PositionService service.
// All implementations must embed UnimplementedPositionServiceServer
// for forward compatibility.
type PositionServiceServer interface {
	CreatePosition(context.Context, *PositionBody) (*BaseIDRes, error)
	DeletePosition(context.Context, *IDsReq) (*BaseRes, error)
	UpdatePosition(context.Context, *PositionBody) (*BaseRes, error)
	GetPosition(context.Context, *IDReq) (*PositionBody, error)
	QueryPosition(context.Context, *PositionListReq) (*PositionListRes, error)
	mustEmbedUnimplementedPositionServiceServer()
}

// UnimplementedPositionServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedPositionServiceServer struct{}

func (UnimplementedPositionServiceServer) CreatePosition(context.Context, *PositionBody) (*BaseIDRes, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreatePosition not implemented")
}
func (UnimplementedPositionServiceServer) DeletePosition(context.Context, *IDsReq) (*BaseRes, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeletePosition not implemented")
}
func (UnimplementedPositionServiceServer) UpdatePosition(context.Context, *PositionBody) (*BaseRes, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdatePosition not implemented")
}
func (UnimplementedPositionServiceServer) GetPosition(context.Context, *IDReq) (*PositionBody, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetPosition not implemented")
}
func (UnimplementedPositionServiceServer) QueryPosition(context.Context, *PositionListReq) (*PositionListRes, error) {
	return nil, status.Errorf(codes.Unimplemented, "method QueryPosition not implemented")
}
func (UnimplementedPositionServiceServer) mustEmbedUnimplementedPositionServiceServer() {}
func (UnimplementedPositionServiceServer) testEmbeddedByValue()                         {}

// UnsafePositionServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to PositionServiceServer will
// result in compilation errors.
type UnsafePositionServiceServer interface {
	mustEmbedUnimplementedPositionServiceServer()
}

func RegisterPositionServiceServer(s grpc.ServiceRegistrar, srv PositionServiceServer) {
	// If the following call pancis, it indicates UnimplementedPositionServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&PositionService_ServiceDesc, srv)
}

func _PositionService_CreatePosition_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PositionBody)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PositionServiceServer).CreatePosition(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PositionService_CreatePosition_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PositionServiceServer).CreatePosition(ctx, req.(*PositionBody))
	}
	return interceptor(ctx, in, info, handler)
}

func _PositionService_DeletePosition_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IDsReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PositionServiceServer).DeletePosition(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PositionService_DeletePosition_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PositionServiceServer).DeletePosition(ctx, req.(*IDsReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _PositionService_UpdatePosition_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PositionBody)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PositionServiceServer).UpdatePosition(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PositionService_UpdatePosition_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PositionServiceServer).UpdatePosition(ctx, req.(*PositionBody))
	}
	return interceptor(ctx, in, info, handler)
}

func _PositionService_GetPosition_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IDReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PositionServiceServer).GetPosition(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PositionService_GetPosition_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PositionServiceServer).GetPosition(ctx, req.(*IDReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _PositionService_QueryPosition_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PositionListReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PositionServiceServer).QueryPosition(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PositionService_QueryPosition_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PositionServiceServer).QueryPosition(ctx, req.(*PositionListReq))
	}
	return interceptor(ctx, in, info, handler)
}

// PositionService_ServiceDesc is the grpc.ServiceDesc for PositionService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var PositionService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "admin_system.PositionService",
	HandlerType: (*PositionServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "createPosition",
			Handler:    _PositionService_CreatePosition_Handler,
		},
		{
			MethodName: "deletePosition",
			Handler:    _PositionService_DeletePosition_Handler,
		},
		{
			MethodName: "updatePosition",
			Handler:    _PositionService_UpdatePosition_Handler,
		},
		{
			MethodName: "getPosition",
			Handler:    _PositionService_GetPosition_Handler,
		},
		{
			MethodName: "queryPosition",
			Handler:    _PositionService_QueryPosition_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "rpc/admin_system/admin_system.proto",
}

const (
	RoleService_CreateRole_FullMethodName = "/admin_system.RoleService/createRole"
	RoleService_DeleteRole_FullMethodName = "/admin_system.RoleService/deleteRole"
	RoleService_UpdateRole_FullMethodName = "/admin_system.RoleService/updateRole"
	RoleService_GetRole_FullMethodName    = "/admin_system.RoleService/getRole"
	RoleService_QueryRole_FullMethodName  = "/admin_system.RoleService/queryRole"
)

// RoleServiceClient is the client API for RoleService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type RoleServiceClient interface {
	CreateRole(ctx context.Context, in *RoleBody, opts ...grpc.CallOption) (*BaseIDRes, error)
	DeleteRole(ctx context.Context, in *IDsReq, opts ...grpc.CallOption) (*BaseRes, error)
	UpdateRole(ctx context.Context, in *RoleBody, opts ...grpc.CallOption) (*BaseRes, error)
	GetRole(ctx context.Context, in *IDReq, opts ...grpc.CallOption) (*RoleBody, error)
	QueryRole(ctx context.Context, in *RoleListReq, opts ...grpc.CallOption) (*RoleListRes, error)
}

type roleServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewRoleServiceClient(cc grpc.ClientConnInterface) RoleServiceClient {
	return &roleServiceClient{cc}
}

func (c *roleServiceClient) CreateRole(ctx context.Context, in *RoleBody, opts ...grpc.CallOption) (*BaseIDRes, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(BaseIDRes)
	err := c.cc.Invoke(ctx, RoleService_CreateRole_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *roleServiceClient) DeleteRole(ctx context.Context, in *IDsReq, opts ...grpc.CallOption) (*BaseRes, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(BaseRes)
	err := c.cc.Invoke(ctx, RoleService_DeleteRole_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *roleServiceClient) UpdateRole(ctx context.Context, in *RoleBody, opts ...grpc.CallOption) (*BaseRes, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(BaseRes)
	err := c.cc.Invoke(ctx, RoleService_UpdateRole_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *roleServiceClient) GetRole(ctx context.Context, in *IDReq, opts ...grpc.CallOption) (*RoleBody, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(RoleBody)
	err := c.cc.Invoke(ctx, RoleService_GetRole_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *roleServiceClient) QueryRole(ctx context.Context, in *RoleListReq, opts ...grpc.CallOption) (*RoleListRes, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(RoleListRes)
	err := c.cc.Invoke(ctx, RoleService_QueryRole_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// RoleServiceServer is the server API for RoleService service.
// All implementations must embed UnimplementedRoleServiceServer
// for forward compatibility.
type RoleServiceServer interface {
	CreateRole(context.Context, *RoleBody) (*BaseIDRes, error)
	DeleteRole(context.Context, *IDsReq) (*BaseRes, error)
	UpdateRole(context.Context, *RoleBody) (*BaseRes, error)
	GetRole(context.Context, *IDReq) (*RoleBody, error)
	QueryRole(context.Context, *RoleListReq) (*RoleListRes, error)
	mustEmbedUnimplementedRoleServiceServer()
}

// UnimplementedRoleServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedRoleServiceServer struct{}

func (UnimplementedRoleServiceServer) CreateRole(context.Context, *RoleBody) (*BaseIDRes, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateRole not implemented")
}
func (UnimplementedRoleServiceServer) DeleteRole(context.Context, *IDsReq) (*BaseRes, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteRole not implemented")
}
func (UnimplementedRoleServiceServer) UpdateRole(context.Context, *RoleBody) (*BaseRes, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateRole not implemented")
}
func (UnimplementedRoleServiceServer) GetRole(context.Context, *IDReq) (*RoleBody, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetRole not implemented")
}
func (UnimplementedRoleServiceServer) QueryRole(context.Context, *RoleListReq) (*RoleListRes, error) {
	return nil, status.Errorf(codes.Unimplemented, "method QueryRole not implemented")
}
func (UnimplementedRoleServiceServer) mustEmbedUnimplementedRoleServiceServer() {}
func (UnimplementedRoleServiceServer) testEmbeddedByValue()                     {}

// UnsafeRoleServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to RoleServiceServer will
// result in compilation errors.
type UnsafeRoleServiceServer interface {
	mustEmbedUnimplementedRoleServiceServer()
}

func RegisterRoleServiceServer(s grpc.ServiceRegistrar, srv RoleServiceServer) {
	// If the following call pancis, it indicates UnimplementedRoleServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&RoleService_ServiceDesc, srv)
}

func _RoleService_CreateRole_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RoleBody)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RoleServiceServer).CreateRole(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RoleService_CreateRole_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RoleServiceServer).CreateRole(ctx, req.(*RoleBody))
	}
	return interceptor(ctx, in, info, handler)
}

func _RoleService_DeleteRole_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IDsReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RoleServiceServer).DeleteRole(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RoleService_DeleteRole_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RoleServiceServer).DeleteRole(ctx, req.(*IDsReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _RoleService_UpdateRole_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RoleBody)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RoleServiceServer).UpdateRole(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RoleService_UpdateRole_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RoleServiceServer).UpdateRole(ctx, req.(*RoleBody))
	}
	return interceptor(ctx, in, info, handler)
}

func _RoleService_GetRole_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IDReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RoleServiceServer).GetRole(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RoleService_GetRole_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RoleServiceServer).GetRole(ctx, req.(*IDReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _RoleService_QueryRole_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RoleListReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RoleServiceServer).QueryRole(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RoleService_QueryRole_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RoleServiceServer).QueryRole(ctx, req.(*RoleListReq))
	}
	return interceptor(ctx, in, info, handler)
}

// RoleService_ServiceDesc is the grpc.ServiceDesc for RoleService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var RoleService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "admin_system.RoleService",
	HandlerType: (*RoleServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "createRole",
			Handler:    _RoleService_CreateRole_Handler,
		},
		{
			MethodName: "deleteRole",
			Handler:    _RoleService_DeleteRole_Handler,
		},
		{
			MethodName: "updateRole",
			Handler:    _RoleService_UpdateRole_Handler,
		},
		{
			MethodName: "getRole",
			Handler:    _RoleService_GetRole_Handler,
		},
		{
			MethodName: "queryRole",
			Handler:    _RoleService_QueryRole_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "rpc/admin_system/admin_system.proto",
}

const (
	UserService_CreateUser_FullMethodName     = "/admin_system.UserService/createUser"
	UserService_DeleteUser_FullMethodName     = "/admin_system.UserService/deleteUser"
	UserService_UpdateUser_FullMethodName     = "/admin_system.UserService/updateUser"
	UserService_GetUser_FullMethodName        = "/admin_system.UserService/getUser"
	UserService_QueryUser_FullMethodName      = "/admin_system.UserService/queryUser"
	UserService_GetUserByEmail_FullMethodName = "/admin_system.UserService/getUserByEmail"
)

// UserServiceClient is the client API for UserService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type UserServiceClient interface {
	CreateUser(ctx context.Context, in *UserBody, opts ...grpc.CallOption) (*BaseIDRes, error)
	DeleteUser(ctx context.Context, in *IDsReq, opts ...grpc.CallOption) (*BaseRes, error)
	UpdateUser(ctx context.Context, in *UserBody, opts ...grpc.CallOption) (*BaseRes, error)
	GetUser(ctx context.Context, in *IDReq, opts ...grpc.CallOption) (*UserBody, error)
	QueryUser(ctx context.Context, in *UserListReq, opts ...grpc.CallOption) (*UserListRes, error)
	GetUserByEmail(ctx context.Context, in *EmailReq, opts ...grpc.CallOption) (*UserBody, error)
}

type userServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewUserServiceClient(cc grpc.ClientConnInterface) UserServiceClient {
	return &userServiceClient{cc}
}

func (c *userServiceClient) CreateUser(ctx context.Context, in *UserBody, opts ...grpc.CallOption) (*BaseIDRes, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(BaseIDRes)
	err := c.cc.Invoke(ctx, UserService_CreateUser_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userServiceClient) DeleteUser(ctx context.Context, in *IDsReq, opts ...grpc.CallOption) (*BaseRes, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(BaseRes)
	err := c.cc.Invoke(ctx, UserService_DeleteUser_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userServiceClient) UpdateUser(ctx context.Context, in *UserBody, opts ...grpc.CallOption) (*BaseRes, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(BaseRes)
	err := c.cc.Invoke(ctx, UserService_UpdateUser_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userServiceClient) GetUser(ctx context.Context, in *IDReq, opts ...grpc.CallOption) (*UserBody, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UserBody)
	err := c.cc.Invoke(ctx, UserService_GetUser_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userServiceClient) QueryUser(ctx context.Context, in *UserListReq, opts ...grpc.CallOption) (*UserListRes, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UserListRes)
	err := c.cc.Invoke(ctx, UserService_QueryUser_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userServiceClient) GetUserByEmail(ctx context.Context, in *EmailReq, opts ...grpc.CallOption) (*UserBody, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UserBody)
	err := c.cc.Invoke(ctx, UserService_GetUserByEmail_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// UserServiceServer is the server API for UserService service.
// All implementations must embed UnimplementedUserServiceServer
// for forward compatibility.
type UserServiceServer interface {
	CreateUser(context.Context, *UserBody) (*BaseIDRes, error)
	DeleteUser(context.Context, *IDsReq) (*BaseRes, error)
	UpdateUser(context.Context, *UserBody) (*BaseRes, error)
	GetUser(context.Context, *IDReq) (*UserBody, error)
	QueryUser(context.Context, *UserListReq) (*UserListRes, error)
	GetUserByEmail(context.Context, *EmailReq) (*UserBody, error)
	mustEmbedUnimplementedUserServiceServer()
}

// UnimplementedUserServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedUserServiceServer struct{}

func (UnimplementedUserServiceServer) CreateUser(context.Context, *UserBody) (*BaseIDRes, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateUser not implemented")
}
func (UnimplementedUserServiceServer) DeleteUser(context.Context, *IDsReq) (*BaseRes, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteUser not implemented")
}
func (UnimplementedUserServiceServer) UpdateUser(context.Context, *UserBody) (*BaseRes, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateUser not implemented")
}
func (UnimplementedUserServiceServer) GetUser(context.Context, *IDReq) (*UserBody, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetUser not implemented")
}
func (UnimplementedUserServiceServer) QueryUser(context.Context, *UserListReq) (*UserListRes, error) {
	return nil, status.Errorf(codes.Unimplemented, "method QueryUser not implemented")
}
func (UnimplementedUserServiceServer) GetUserByEmail(context.Context, *EmailReq) (*UserBody, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetUserByEmail not implemented")
}
func (UnimplementedUserServiceServer) mustEmbedUnimplementedUserServiceServer() {}
func (UnimplementedUserServiceServer) testEmbeddedByValue()                     {}

// UnsafeUserServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to UserServiceServer will
// result in compilation errors.
type UnsafeUserServiceServer interface {
	mustEmbedUnimplementedUserServiceServer()
}

func RegisterUserServiceServer(s grpc.ServiceRegistrar, srv UserServiceServer) {
	// If the following call pancis, it indicates UnimplementedUserServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&UserService_ServiceDesc, srv)
}

func _UserService_CreateUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserBody)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServiceServer).CreateUser(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserService_CreateUser_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServiceServer).CreateUser(ctx, req.(*UserBody))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserService_DeleteUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IDsReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServiceServer).DeleteUser(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserService_DeleteUser_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServiceServer).DeleteUser(ctx, req.(*IDsReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserService_UpdateUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserBody)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServiceServer).UpdateUser(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserService_UpdateUser_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServiceServer).UpdateUser(ctx, req.(*UserBody))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserService_GetUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IDReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServiceServer).GetUser(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserService_GetUser_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServiceServer).GetUser(ctx, req.(*IDReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserService_QueryUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserListReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServiceServer).QueryUser(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserService_QueryUser_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServiceServer).QueryUser(ctx, req.(*UserListReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserService_GetUserByEmail_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EmailReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServiceServer).GetUserByEmail(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserService_GetUserByEmail_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServiceServer).GetUserByEmail(ctx, req.(*EmailReq))
	}
	return interceptor(ctx, in, info, handler)
}

// UserService_ServiceDesc is the grpc.ServiceDesc for UserService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var UserService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "admin_system.UserService",
	HandlerType: (*UserServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "createUser",
			Handler:    _UserService_CreateUser_Handler,
		},
		{
			MethodName: "deleteUser",
			Handler:    _UserService_DeleteUser_Handler,
		},
		{
			MethodName: "updateUser",
			Handler:    _UserService_UpdateUser_Handler,
		},
		{
			MethodName: "getUser",
			Handler:    _UserService_GetUser_Handler,
		},
		{
			MethodName: "queryUser",
			Handler:    _UserService_QueryUser_Handler,
		},
		{
			MethodName: "getUserByEmail",
			Handler:    _UserService_GetUserByEmail_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "rpc/admin_system/admin_system.proto",
}
