// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"fmt"

	"github.com/DrReMain/cyber-ecosystem-server/rpc/admin_system/ent/department"
	"github.com/DrReMain/cyber-ecosystem-server/rpc/admin_system/ent/menu"
	"github.com/DrReMain/cyber-ecosystem-server/rpc/admin_system/ent/position"
	"github.com/DrReMain/cyber-ecosystem-server/rpc/admin_system/ent/resource"
	"github.com/DrReMain/cyber-ecosystem-server/rpc/admin_system/ent/role"
	"github.com/DrReMain/cyber-ecosystem-server/rpc/admin_system/ent/user"
)

type PageDetail struct {
	PageNo   uint64 `json:"page_no"`
	PageSize uint64 `json:"page_size"`
	Total    uint64 `json:"total"`
	More     bool   `json:"more"`
}

// OrderDirection defines the directions in which to order a list of items.
type OrderDirection string

const (
	// OrderDirectionAsc specifies an ascending order.
	OrderDirectionAsc OrderDirection = "ASC"
	// OrderDirectionDesc specifies a descending order.
	OrderDirectionDesc OrderDirection = "DESC"
)

// Validate the order direction value.
func (o OrderDirection) Validate() error {
	if o != OrderDirectionAsc && o != OrderDirectionDesc {
		return fmt.Errorf("%s is not a valid OrderDirection", o)
	}
	return nil
}

// String implements fmt.Stringer interface.
func (o OrderDirection) String() string {
	return string(o)
}

func (o OrderDirection) reverse() OrderDirection {
	if o == OrderDirectionDesc {
		return OrderDirectionAsc
	}
	return OrderDirectionDesc
}

type DepartmentPager struct {
	Order  []department.OrderOption
	Filter func(*DepartmentQuery) (*DepartmentQuery, error)
}

type DepartmentPaginateOption func(*DepartmentPager)

var DefaultDepartmentOrder = Desc(department.FieldID)

func newDepartmentPager(opts []DepartmentPaginateOption) (*DepartmentPager, error) {
	pager := &DepartmentPager{}
	for _, opt := range opts {
		opt(pager)
	}
	if pager.Order == nil {
		pager.Order = []department.OrderOption{DefaultDepartmentOrder}
	}
	return pager, nil
}

func (p *DepartmentPager) ApplyFilter(query *DepartmentQuery) (*DepartmentQuery, error) {
	if p.Filter != nil {
		return p.Filter(query)
	}
	return query, nil
}

// DepartmentPageList is Department PageList result.
type DepartmentPageList struct {
	List       []*Department `json:"list"`
	PageDetail *PageDetail   `json:"page_detail"`
}

func (d *DepartmentQuery) Page(
	ctx context.Context, pageNo *uint64, pageSize *uint64, defaultSize, maxSize uint64, opts ...DepartmentPaginateOption,
) (*DepartmentPageList, error) {
	var p, s uint64
	if pageNo != nil {
		p = *pageNo
	}
	if pageSize != nil {
		s = *pageSize
	}
	if defaultSize > 0 && s == 0 {
		s = defaultSize
	}

	pager, err := newDepartmentPager(opts)
	if err != nil {
		return nil, err
	}

	if d, err = pager.ApplyFilter(d); err != nil {
		return nil, err
	}

	ret := &DepartmentPageList{}

	query := d.Clone()
	query.ctx.Fields = nil
	count, err := query.Count(ctx)

	if err != nil {
		return nil, err
	}

	total := uint64(count)
	if p == 0 {
		p = 1
	}
	if s == 0 {
		s = total
	}
	if maxSize > 0 && s > maxSize {
		s = maxSize
	}
	ret.PageDetail = &PageDetail{
		PageNo:   p,
		PageSize: s,
		Total:    total,
		More:     p*s < total,
	}

	if pager.Order != nil {
		d = d.Order(pager.Order...)
	} else {
		d = d.Order(DefaultDepartmentOrder)
	}

	d = d.Offset(int((p - 1) * s)).Limit(int(s))
	list, err := d.All(ctx)
	if err != nil {
		return nil, err
	}
	ret.List = list

	return ret, nil
}

type MenuPager struct {
	Order  []menu.OrderOption
	Filter func(*MenuQuery) (*MenuQuery, error)
}

type MenuPaginateOption func(*MenuPager)

var DefaultMenuOrder = Desc(menu.FieldID)

func newMenuPager(opts []MenuPaginateOption) (*MenuPager, error) {
	pager := &MenuPager{}
	for _, opt := range opts {
		opt(pager)
	}
	if pager.Order == nil {
		pager.Order = []menu.OrderOption{DefaultMenuOrder}
	}
	return pager, nil
}

func (p *MenuPager) ApplyFilter(query *MenuQuery) (*MenuQuery, error) {
	if p.Filter != nil {
		return p.Filter(query)
	}
	return query, nil
}

// MenuPageList is Menu PageList result.
type MenuPageList struct {
	List       []*Menu     `json:"list"`
	PageDetail *PageDetail `json:"page_detail"`
}

func (m *MenuQuery) Page(
	ctx context.Context, pageNo *uint64, pageSize *uint64, defaultSize, maxSize uint64, opts ...MenuPaginateOption,
) (*MenuPageList, error) {
	var p, s uint64
	if pageNo != nil {
		p = *pageNo
	}
	if pageSize != nil {
		s = *pageSize
	}
	if defaultSize > 0 && s == 0 {
		s = defaultSize
	}

	pager, err := newMenuPager(opts)
	if err != nil {
		return nil, err
	}

	if m, err = pager.ApplyFilter(m); err != nil {
		return nil, err
	}

	ret := &MenuPageList{}

	query := m.Clone()
	query.ctx.Fields = nil
	count, err := query.Count(ctx)

	if err != nil {
		return nil, err
	}

	total := uint64(count)
	if p == 0 {
		p = 1
	}
	if s == 0 {
		s = total
	}
	if maxSize > 0 && s > maxSize {
		s = maxSize
	}
	ret.PageDetail = &PageDetail{
		PageNo:   p,
		PageSize: s,
		Total:    total,
		More:     p*s < total,
	}

	if pager.Order != nil {
		m = m.Order(pager.Order...)
	} else {
		m = m.Order(DefaultMenuOrder)
	}

	m = m.Offset(int((p - 1) * s)).Limit(int(s))
	list, err := m.All(ctx)
	if err != nil {
		return nil, err
	}
	ret.List = list

	return ret, nil
}

type PositionPager struct {
	Order  []position.OrderOption
	Filter func(*PositionQuery) (*PositionQuery, error)
}

type PositionPaginateOption func(*PositionPager)

var DefaultPositionOrder = Desc(position.FieldID)

func newPositionPager(opts []PositionPaginateOption) (*PositionPager, error) {
	pager := &PositionPager{}
	for _, opt := range opts {
		opt(pager)
	}
	if pager.Order == nil {
		pager.Order = []position.OrderOption{DefaultPositionOrder}
	}
	return pager, nil
}

func (p *PositionPager) ApplyFilter(query *PositionQuery) (*PositionQuery, error) {
	if p.Filter != nil {
		return p.Filter(query)
	}
	return query, nil
}

// PositionPageList is Position PageList result.
type PositionPageList struct {
	List       []*Position `json:"list"`
	PageDetail *PageDetail `json:"page_detail"`
}

func (po *PositionQuery) Page(
	ctx context.Context, pageNo *uint64, pageSize *uint64, defaultSize, maxSize uint64, opts ...PositionPaginateOption,
) (*PositionPageList, error) {
	var p, s uint64
	if pageNo != nil {
		p = *pageNo
	}
	if pageSize != nil {
		s = *pageSize
	}
	if defaultSize > 0 && s == 0 {
		s = defaultSize
	}

	pager, err := newPositionPager(opts)
	if err != nil {
		return nil, err
	}

	if po, err = pager.ApplyFilter(po); err != nil {
		return nil, err
	}

	ret := &PositionPageList{}

	query := po.Clone()
	query.ctx.Fields = nil
	count, err := query.Count(ctx)

	if err != nil {
		return nil, err
	}

	total := uint64(count)
	if p == 0 {
		p = 1
	}
	if s == 0 {
		s = total
	}
	if maxSize > 0 && s > maxSize {
		s = maxSize
	}
	ret.PageDetail = &PageDetail{
		PageNo:   p,
		PageSize: s,
		Total:    total,
		More:     p*s < total,
	}

	if pager.Order != nil {
		po = po.Order(pager.Order...)
	} else {
		po = po.Order(DefaultPositionOrder)
	}

	po = po.Offset(int((p - 1) * s)).Limit(int(s))
	list, err := po.All(ctx)
	if err != nil {
		return nil, err
	}
	ret.List = list

	return ret, nil
}

type ResourcePager struct {
	Order  []resource.OrderOption
	Filter func(*ResourceQuery) (*ResourceQuery, error)
}

type ResourcePaginateOption func(*ResourcePager)

var DefaultResourceOrder = Desc(resource.FieldID)

func newResourcePager(opts []ResourcePaginateOption) (*ResourcePager, error) {
	pager := &ResourcePager{}
	for _, opt := range opts {
		opt(pager)
	}
	if pager.Order == nil {
		pager.Order = []resource.OrderOption{DefaultResourceOrder}
	}
	return pager, nil
}

func (p *ResourcePager) ApplyFilter(query *ResourceQuery) (*ResourceQuery, error) {
	if p.Filter != nil {
		return p.Filter(query)
	}
	return query, nil
}

// ResourcePageList is Resource PageList result.
type ResourcePageList struct {
	List       []*Resource `json:"list"`
	PageDetail *PageDetail `json:"page_detail"`
}

func (r *ResourceQuery) Page(
	ctx context.Context, pageNo *uint64, pageSize *uint64, defaultSize, maxSize uint64, opts ...ResourcePaginateOption,
) (*ResourcePageList, error) {
	var p, s uint64
	if pageNo != nil {
		p = *pageNo
	}
	if pageSize != nil {
		s = *pageSize
	}
	if defaultSize > 0 && s == 0 {
		s = defaultSize
	}

	pager, err := newResourcePager(opts)
	if err != nil {
		return nil, err
	}

	if r, err = pager.ApplyFilter(r); err != nil {
		return nil, err
	}

	ret := &ResourcePageList{}

	query := r.Clone()
	query.ctx.Fields = nil
	count, err := query.Count(ctx)

	if err != nil {
		return nil, err
	}

	total := uint64(count)
	if p == 0 {
		p = 1
	}
	if s == 0 {
		s = total
	}
	if maxSize > 0 && s > maxSize {
		s = maxSize
	}
	ret.PageDetail = &PageDetail{
		PageNo:   p,
		PageSize: s,
		Total:    total,
		More:     p*s < total,
	}

	if pager.Order != nil {
		r = r.Order(pager.Order...)
	} else {
		r = r.Order(DefaultResourceOrder)
	}

	r = r.Offset(int((p - 1) * s)).Limit(int(s))
	list, err := r.All(ctx)
	if err != nil {
		return nil, err
	}
	ret.List = list

	return ret, nil
}

type RolePager struct {
	Order  []role.OrderOption
	Filter func(*RoleQuery) (*RoleQuery, error)
}

type RolePaginateOption func(*RolePager)

var DefaultRoleOrder = Desc(role.FieldID)

func newRolePager(opts []RolePaginateOption) (*RolePager, error) {
	pager := &RolePager{}
	for _, opt := range opts {
		opt(pager)
	}
	if pager.Order == nil {
		pager.Order = []role.OrderOption{DefaultRoleOrder}
	}
	return pager, nil
}

func (p *RolePager) ApplyFilter(query *RoleQuery) (*RoleQuery, error) {
	if p.Filter != nil {
		return p.Filter(query)
	}
	return query, nil
}

// RolePageList is Role PageList result.
type RolePageList struct {
	List       []*Role     `json:"list"`
	PageDetail *PageDetail `json:"page_detail"`
}

func (r *RoleQuery) Page(
	ctx context.Context, pageNo *uint64, pageSize *uint64, defaultSize, maxSize uint64, opts ...RolePaginateOption,
) (*RolePageList, error) {
	var p, s uint64
	if pageNo != nil {
		p = *pageNo
	}
	if pageSize != nil {
		s = *pageSize
	}
	if defaultSize > 0 && s == 0 {
		s = defaultSize
	}

	pager, err := newRolePager(opts)
	if err != nil {
		return nil, err
	}

	if r, err = pager.ApplyFilter(r); err != nil {
		return nil, err
	}

	ret := &RolePageList{}

	query := r.Clone()
	query.ctx.Fields = nil
	count, err := query.Count(ctx)

	if err != nil {
		return nil, err
	}

	total := uint64(count)
	if p == 0 {
		p = 1
	}
	if s == 0 {
		s = total
	}
	if maxSize > 0 && s > maxSize {
		s = maxSize
	}
	ret.PageDetail = &PageDetail{
		PageNo:   p,
		PageSize: s,
		Total:    total,
		More:     p*s < total,
	}

	if pager.Order != nil {
		r = r.Order(pager.Order...)
	} else {
		r = r.Order(DefaultRoleOrder)
	}

	r = r.Offset(int((p - 1) * s)).Limit(int(s))
	list, err := r.All(ctx)
	if err != nil {
		return nil, err
	}
	ret.List = list

	return ret, nil
}

type UserPager struct {
	Order  []user.OrderOption
	Filter func(*UserQuery) (*UserQuery, error)
}

type UserPaginateOption func(*UserPager)

var DefaultUserOrder = Desc(user.FieldID)

func newUserPager(opts []UserPaginateOption) (*UserPager, error) {
	pager := &UserPager{}
	for _, opt := range opts {
		opt(pager)
	}
	if pager.Order == nil {
		pager.Order = []user.OrderOption{DefaultUserOrder}
	}
	return pager, nil
}

func (p *UserPager) ApplyFilter(query *UserQuery) (*UserQuery, error) {
	if p.Filter != nil {
		return p.Filter(query)
	}
	return query, nil
}

// UserPageList is User PageList result.
type UserPageList struct {
	List       []*User     `json:"list"`
	PageDetail *PageDetail `json:"page_detail"`
}

func (u *UserQuery) Page(
	ctx context.Context, pageNo *uint64, pageSize *uint64, defaultSize, maxSize uint64, opts ...UserPaginateOption,
) (*UserPageList, error) {
	var p, s uint64
	if pageNo != nil {
		p = *pageNo
	}
	if pageSize != nil {
		s = *pageSize
	}
	if defaultSize > 0 && s == 0 {
		s = defaultSize
	}

	pager, err := newUserPager(opts)
	if err != nil {
		return nil, err
	}

	if u, err = pager.ApplyFilter(u); err != nil {
		return nil, err
	}

	ret := &UserPageList{}

	query := u.Clone()
	query.ctx.Fields = nil
	count, err := query.Count(ctx)

	if err != nil {
		return nil, err
	}

	total := uint64(count)
	if p == 0 {
		p = 1
	}
	if s == 0 {
		s = total
	}
	if maxSize > 0 && s > maxSize {
		s = maxSize
	}
	ret.PageDetail = &PageDetail{
		PageNo:   p,
		PageSize: s,
		Total:    total,
		More:     p*s < total,
	}

	if pager.Order != nil {
		u = u.Order(pager.Order...)
	} else {
		u = u.Order(DefaultUserOrder)
	}

	u = u.Offset(int((p - 1) * s)).Limit(int(s))
	list, err := u.All(ctx)
	if err != nil {
		return nil, err
	}
	ret.List = list

	return ret, nil
}
